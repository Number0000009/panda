TODO:

Maybe we can use this somehow instead of creating mappings?

7.4.4 Shared Cache MMU Registers
For information about the shared cache MMU registers and their description, see Chapter 5, DSP
Subsystem.
The shared cache MMU in Cortex-M3 has four large pages, two medium pages, and ten small pages.
Because of the different page sizes, there are differences with the registers described in Chapter 5, DSP
Subsystem, in the enumerated indexes below the register mapping, which are the following: (i = 0 to 3), (j
= 0 to 1), (k = 0 to 9). There are also differences in the reset value of the following registers:
• SCACHE_MMU_SMALL_ADDR_0 with reset value 0x00000000
• SCACHE_MMU_SMALL_ADDR_1 with reset value 0x40000000
• SCACHE_MMU_SMALL_POLICY_k with reset value 0x0000000 (k = 0 to 9)
• SCACHE_MMU_SMALL_XLTE_0 with reset value 0x55020000
• SCACHE_MMU_SMALL_XLTE_1 with reset value 0x55080000
• SCACHE_MMU_SMALL_XLTE_k with reset value 0x00000000 (k = 2 to 9)
The page sizes for the 16 entries are:
• Large pages (four): The page size supported are 32 MB and 512 MB.
• Medium pages (two): The page sizes supported are 128 KB and 256 KB.
• Small pages (ten): The page sizes supported are 4 KB and 16 KB.

================================================================================



wake up cortex-m3
# ---------------------------------------------------------------------
# 1. Set CM_MPU_M3_MPU_M3_CLKCTRL to AUTO mode (MODULEMODE = 0x1)
mw.l 0x4A008920 0x1

# 2. Set CM_MPU_M3_CLKSTCTRL to SW_WKUP (CLKTRCTRL = 0x2)
mw.l 0x4A008900 0x2

# 3. Program the reset timer for PRCM internal deassertion
mw.l 0x4A307100 0x00007C00

# ---------------------------------------------------------------------
# 4. Assert all resets: RST3 | RST2 | RST1
mw.l 0x4A306910 0x7

# ---------------------------------------------------------------------
# 5. Release MMU/cache reset (clear RST3)
mw.l 0x4A306910 0x3

# 6. Wait until RST3 (bit 2) is latched in RM_MPU_M3_RSTST
:wait_rst3
md.l 0x4A306914       # Look for bit 2 == 1 (value = 0x4)

# 7. Clear RST3 status
mw.l 0x4A306914 0x4

# ---------------------------------------------------------------------
# 8. Release M3_0 reset (clear RST1)
mw.l 0x4A306910 0x2

# 9. Wait until RST1 (bit 0) is latched in RM_MPU_M3_RSTST
:wait_rst1
md.l 0x4A306914       # Look for bit 0 == 1 (value = 0x1)

# 10. Clear RST1 status
mw.l 0x4A306914 0x1

# ---------------------------------------------------------------------
# 11. Release M3_1 reset (clear RST2)
mw.l 0x4A306910 0x0

# 12. Wait until RST2 (bit 1) is latched in RM_MPU_M3_RSTST
:wait_rst2
md.l 0x4A306914       # Look for bit 1 == 1 (value = 0x2)

# 13. Clear RST2 status
mw.l 0x4A306914 0x2

-------------------------------------------------------------------------------

Cortex-A9 @ 0x55020000 sees the same as Cortex-M3 @ 0x55020000 (SRAM?)
          @ 0x40300000                            @ 0x40300000

Cortex-M3 side 0xe000ed00 - SCB registers

Fault occurs on access to 0xe000edf8 - Vector BAR - pointing to 0 and we have no
memroy at 0 Physical Address on the Cortex-M3. Seems like what we need is to
somehow map a valid memory to 0 VA so Cortex-M3 can see vectors...


# Make sure IPU/Ducati clocks are ON so these registers respond:
mw.l 0x4A008900 0x00000002          # CM_DUCATI_CLKSTCTRL = SW_WKUP
mw.l 0x4A008920 0x00000002          # CM_DUCATI_DUCATI_CLKCTRL MODULEMODE=ENABLED

# Ensure IOMMU is disabled while programming
mw.l 0x55082044 0x00000000          # MMU_CNTL = 0

# Program TLB entry #0 :  VA 0x00000000 (1MiB)  ->  PA 0x40300000
mw.l 0x55082050 0x00000000          # MMU_LOCK: base=0, vict=0
mw.l 0x55082058 0x00000004          # MMU_CAM: V=1 (bit2), PGSZ=1M (0), VATAG=0
mw.l 0x5508205C 0x40300000          # MMU_RAM: PA=0x40300000 (aligned)

mw.l 0x55082054 0x00000001          # MMU_LD_TLB: load the entry

# (Sanity) Read back what HW latched
md.l 0x55082068 1                   # READ_CAM -> expect 0x...000004
md.l 0x5508206C 1                   # READ_RAM -> expect 0x40300000

# Now enable the IOMMU
mw.l 0x55082044 0x00000002          # MMU_CNTL.MMU_EN=1

# Lay minimal vectors in OCMC (PA 0x40300000), using *VA* values in the entries:
mw.l 0x40300000 0x00010000          # [0] SP = 0x00010000 (any valid RAM top)
mw.l 0x40300004 0x00000101          # [4] PC = 0x00000100 | Thumb
mw.l 0x40300100 0xE7FEE7FE          # 0x00000100: b .

# Release M3_0 reset



# --- IPU IOMMU: ONLY VA=0 -> OCMC (lock it), then enable ---
mw.l 0x55082044 0x00000000          # MMU_CNTL = 0 (disable)
mw.l 0x55082050 0x00000000          # LOCK: base=0, victim=0
mw.l 0x55082058 0x00000004          # CAM : V=1, PGSZ=1MiB, VATAG=0x00000000
mw.l 0x5508205C 0x40300000          # RAM : PA=0x40300000
mw.l 0x55082054 0x00000001          # LD_TLB
mw.l 0x55082050 0x00000100          # LOCK.base=1 (lock entry 0), victim=0
mw.l 0x55082044 0x00000002          # MMU_CNTL.MMU_EN = 1

# --- Vectors in OCMC (values are M3 VAs) ---
mw.l 0x40300000 0x00010000          # [0] SP
mw.l 0x40300004 0x00000101          # [4] Reset -> code @ 0x00000100 (Thumb)

# (optional harden the rest of vectors)
mw.l 0x40300008 0x00000101          # NMI
mw.l 0x4030000C 0x00000101          # HardFault
mw.l 0x40300010 0x00000101          # MemManage
mw.l 0x40300014 0x00000101          # BusFault
mw.l 0x40300018 0x00000101          # UsageFault
mw.l 0x40300020 0x00000101          # SVCall
mw.l 0x40300024 0x00000101          # DebugMon
mw.l 0x4030002C 0x00000101          # PendSV
mw.l 0x40300030 0x00000101          # SysTick

# --- Reset @ 0x4030_0100: write cookie to VA 0x00001000, then spin ---
# r0 = 0x00001000 (VA) via literal @ 0x4030_0180
mw.w 0x40300100 0x481F          # ldr  r0, [pc, #124]  -> 0x40300180
# r1 = 0xC0DEF00D (cookie) via literal @ 0x4030_0184
mw.w 0x40300102 0x4920          # ldr  r1, [pc, #128]  -> 0x40300184
mw.w 0x40300104 0x6001          # str  r1, [r0, #0]    ; *(VA 0x00001000) = cookie
mw.w 0x40300106 0xE7FE          # b .

# Literals for the LDRs above
mw.l 0x40300180 0x00001000      # target VA within the 1MiB VA=0 page
mw.l 0x40300184 0xDEADC0DE      # cookie value

# Release M3_0

# Verify from A9
# md.l 0x40301000 1               # expect: DEADC0DE

--------------------------------------------------------------------------------
Two mappings:

mw.l 0x55082044 0x00000000           # CNTL: MMU disable
mw.l 0x55082050 0x00000000           # LOCK: base=0, victim=0

# Entry 0: VA 0x0000_0000 -> PA 0x4030_0000
mw.l 0x55082058 0x00000004           # CAM: VA 0x00000000, V=1, 1MiB
mw.l 0x5508205C 0x40300000           # RAM: PA 0x40300000
mw.l 0x55082054 0x00000001           # LD_TLB  -> slot 0
mw.l 0x55082050 0x00000410           # LOCK: BASEVALUE=1, CURRENTVICTIM=1  (lock 0; next=1)

# Entry 1: VA 0x5500_0000 -> PA 0x5500_0000
mw.l 0x55082058 0x55000004           # CAM: VA 0x55000000, V=1, 1MiB
mw.l 0x5508205C 0x55000000           # RAM: PA 0x55000000
mw.l 0x55082054 0x00000001           # LD_TLB  -> slot 1
mw.l 0x55082050 0x00000820           # LOCK: BASEVALUE=2, CURRENTVICTIM=2  (lock 0..1; next=2)

mw.l 0x55082044 0x00000002           # CNTL: MMU_EN = 1

--------------------------------------------------------------------------------
UART3(48020000) mappipng:

mw.l 0x55082058 0x48000004           # CAM
mw.l 0x5508205C 0x48000000           # RAM
mw.l 0x55082054 0x00000001           # LD_TLB (slot 1)
mw.l 0x55082050 0x00000820           # LOCK(base=2, victim=2)


Full sequence:
mw.l 0x4A008920 0x1
mw.l 0x4A008900 0x2
mw.l 0x4A307100 0x00007C00
mw.l 0x4A306910 0x7
mw.l 0x4A306910 0x3
mw.l 0x4A306914 0x4

mw.l 0x55082044 0x00000000           # CNTL: MMU disable
mw.l 0x55082050 0x00000000           # LOCK: base=0, victim=0

mw.l 0x55082058 0x00000004           # CAM: VA 0x00000000, V=1, 1MiB
mw.l 0x5508205C 0x40300000           # RAM: PA 0x40300000
mw.l 0x55082054 0x00000001           # LD_TLB
mw.l 0x55082050 0x00000410           # LOCK: BASEVALUE=1, CURRENTVICTIM=1

#mw.l 0x55082058 0x48000004           # CAM identity
#mw.l 0x5508205C 0x48000000           # RAM identity

#mw.l 0x55082058 0x48020006           # CAM: V=1 | PGSZ_4K(2)
#mw.l 0x5508205C 0x48020040           # RAM: PA | MIXED | little | ELSZ=8
#mw.l 0x55082054 0x00000001           # LD_TLB
#mw.l 0x55082050 0x00000820           # LOCK(base=2, victim=2)

mw.l 0x55082058 0x48020006          # CAM: V=1, PGSZ=4KB, VATAG=0x48020000
mw.l 0x5508205C 0x48020000          # RAM: PA (ENDIAN=0, ELSZ=8, MIXED=0)
mw.l 0x55082054 0x00000001          # LD_TLB
mw.l 0x55082050 0x00000820          # LOCK: base=2, vict=2  (protect 0..1)

#mw.l 0x55082058 0x48000004           # CAM: V=1, PGSZ=1MB, VATAG=0x48000000
#mw.l 0x5508205C 0x48000040           # RAM: PA=0x48000000, MIXED=1, little, ELSZ=8-bit
#mw.l 0x55082054 0x00000001
#mw.l 0x55082050 0x00000820

mw.l 0x55082044 0x00000002          # CNTL: MMU_EN = 1

mw.l 0x40300000 0x00010000          # [0] SP = 0x00010000 (any valid RAM top)
mw.l 0x40300004 0x00000101          # [4] PC = 0x00000100 | Thumb
mw.l 0x40300100 0xE7FEE7FE          # 0x00000100: b .; b .


---
mw.l 0x40300100 0x21214803          # LDR r0, [PC, #12] ; MOVS r1,#33 ('!')
mw.l 0x40300104 0xE7FE7001          # STRB r1,[r0,#0]; B .
mw.l 0x40300110 0x48020000          # = UART3 base
---

mw.l 0x4A306910 0x2

